//============================================================================================// UFCom_XML2Igor.ipf   originally from XML2IgorPro.ipf// 2007 January// Rev History//	UF	070124	removed logical errors, tidied up and generalised the code//	UF	070125	allows numbers as a main key//	UF	070126	allows multiple subkeys for one main key. The subkeys are stored in a list ( e.g. 1 recipe contains multiple ingredients )#pragma version=1.11#pragma rtGlobals=1									// Use modern global access method.#pragma IgorVersion=5.0static constant		kREDUCE_PRINT	=  1				// print only 1 line for every 'kREDUCE_PRINT' linesstatic strconstant	ksXSL_NB_NM		= "ParseXSLNB"static strconstant	ksXML_NB_NM		= "ParseXMLNB"//============================================================================================//  XML  LOW  LEVEL  ROUTINES//// Original file was  XML2IgorPro.ipf,  2006.12.13,   J. J. Weimer    from Igor User Contributions//// Procedure files to parse an XML file and store it//// The XML file must have an XSL file containing definitions for// XSL:TEMPLATE MATCH=//"string": the name of each item// VALUE-OF SELECT="string": the name of the value a given item// VALUE-OF STORE="string": the keyword to use in keyword=value Igor Pro storage// VALUE-OF XUNITS="string": an optional multiplier value to that will be used to correct to a given unit system//// The XSL style values are stored in root:Packages:XML2IgorPro:filenameXSL// ename: string wave of SELECT values// sname: string wave of STORE values// xunits: wave of XUNIT multiplier values//// The XML data are stored as keyword=value strings in a user defined folder//// Access to Package//// --> inputXSLFile(whereXSL) : call this FIRST to read, parse, and store XSL file// --> inputXMLFile(how, whereXML,whereXSL) : call this to read, parse, and store XML file//// KNOWN LIMITATIONS (workaround)// -- Can only read ONE element type (create separate XSL/XML files for other element types)// -- All elements must have all listed properties (create "empty" values as <property></property>)// -- Reads element information to keyword=value list (no work around ...)Function		XSLInput( sFilePath, where)// where: data folder to store XSL parameters (within XML2IgorPro)// read the XSL file, parse the XSL file, kill the XSL file// return: -1 failed to read file; 0 no parameters; >0 # parameters	string 	sFilePath, where		if ( ! DataFolderExists( "root:Packages:XML2IgorPro" ) )		XMLInitParse()	endif		if ( XSLRead( sFilePath ) >0 )		return ( XSLParse( where ) )	else		return -1	endifEndFunction		XMLInput( sFilePath, how, whereXML, whereXSL, sKey, bDebugPrint)// how: how to input XML file :  //	 0 - as keyword=value list (only option currently supported)// whereXML: data folder to store XML keyword=value strings// whereXSL: data folder with XSL parameters (within XML2IgorPro)// read the XML file, parse the XML file, kill the XML file// return: -1 failed to read file; 0 no parameters; >0 number of  parameters	variable	how, bDebugPrint	string  	sFilePath, whereXML, whereXSL, sKey		if ( XMLRead( sFilePath ) > 0 )		return ( XMLParse( how, whereXML, whereXSL, sKey, bDebugPrint ) )	else		return -1	endifEnd// *************************************************************************************************************// ENTRY POINTS TO FUNCTIONS ARE ABOVE THIS LINE// Functions BELOW this point are SPECIFIC to this PACKAGEstatic Function 		XMLInitParse()// create package folders// return: 0-already existed; 1-newly created	string  	cdf	= GetDataFolder(1)	variable	rc	= 0	if (!DataFolderExists("root:Packages"))		NewDataFolder root:Packages	endif	if (!DataFolderExists("root:Packages:XML2IgorPro"))		NewDataFolder/S root:Packages:XML2IgorPro		string/G currXMLData, currXSLData		rc = 1	endif		SetDataFolder $cdf	return rcEndstatic Function 		XSLRead( sFilePath )// read the XML style sheet file as a notebook// return: 0-unsuccessful; 1-successful	string  	sFilePath	if ( UFCom_FileExists( sFilePath ) )		if ( WinType( ksXSL_NB_NM ) ==  5 ) 	// is Notebook			KillWindow	$ksXSL_NB_NM		endif		OpenNotebook /R /V=0 /k=1 /N=$ksXSL_NB_NM  sFilePath		printf "\t\tXSLRead(\t'%s' ) has opened file as notebook. \r", sFilePath		return 1	endif	printf "Error:\tXSLRead(\t'%s' ) could not open file as notebook. \r", sFilePath	return -1Endstatic Function 		XSLParse( where )// where: string name of folder to store XSL parameters// parse the XML style sheet file from notebook// return: number of style elements found in file	string  	where	SVAR currXSLData = root:Packages:XML2IgorPro:currXSLData		printf "\t\tXSLParse(a '%s' ) \r", where 	where = ReplaceString(" ",where,"")	printf "\t\tXSLParse(b '%s' ) \r", where 		string df = "root:Packages:XML2IgorPro:" + where +"XSL"	if (!DatafolderExists(df))		NewDataFolder $df	endif		currXSLData = df		string cdf=GetDataFolder(1)		SetDataFolder $currXSLData		string/G eKey	make/o/n=1/T ename, sname	make/o/n=1 xunits		variable spo, spf, spo1, ic		string nb = ksXSL_NB_NM	string fstr, qstr = "\""		// search lines for MATCH code		Notebook $nb selection={startofFile,startofFile}, findText={"match=//",0}	if (!V_flag)		DoAlert 0, "No match string  'match=//'  in XSL file"		return 0	endif		Notebook $nb selection={startOfParagraph, endOfChars}	GetSelection notebook, $nb, 2	spo=strsearch(S_selection,"//",0)	spf =strsearch(S_selection,">",spo,2)-2	fstr = LowerStr(S_selection[spo+3,spf])	eKey = fstr		//print fstr	//return 0		// search lines for value-of codes		ic = 0		do		Notebook $nb selection={startofNextParagraph,startofNextParagraph}, findText={"value-of",0}		if (!V_flag)			break		endif				Redimension/N=( ic+1 ) ename, sname, xunits		Notebook $nb selection={startOfParagraph, endOfChars}		GetSelection notebook, $nb, 2		//print ic, S_selection			// select code				spo1 = strsearch(S_selection,"select=",0,2)		spf =strsearch(S_selection,qstr,spo1+8,2)-1		fstr = LowerStr(S_selection[spo1+8,spf])		//print fstr		ename[ ic ] = fstr			// store code				spo1 = strsearch(S_selection,"store=",0,2)		spf =strsearch(S_selection,qstr,spo1+7,2)-1		fstr = LowerStr(S_selection[spo1+7,spf])		//print fstr		sname[ ic ] = fstr			// xunits value				spo1 = strsearch(S_selection,"xunits=",0,2)		if (spo1<0)			xunits[ ic ] = NaN		else			spf =strsearch(S_selection,qstr,spo1+8,2)-1			fstr = LowerStr(S_selection[spo1+8,spf])			//print fstr			//xunits[ ic ] = str2num( fstr )			sscanf fstr,"%g", spo			xunits[ic] = spo		endif			//print S_selection		ic +=1	while(1)		SetDataFolder $cdf		KillWindow $nb		return icEndstatic Function		XMLRead( sFilePath )// read the XML file as a notebook// return: 0-unsuccessful; 1-successful	string  	sFilePath	svar  	currXMLData = root:Packages:XML2IgorPro:currXMLData	if ( UFCom_FileExists( sFilePath ) )		if ( WinType( ksXML_NB_NM ) ==  5 ) 	// is Notebook			KillWindow	$ksXML_NB_NM		endif		OpenNotebook /R /V=0 /k=1 /N=$ksXML_NB_NM  sFilePath		printf "\t\tXMLRead(\t'%s' ) has opened file as notebook. \r", sFilePath		return 1	endif	printf "Error:\tXMLRead(\t'%s' ) could not open file as notebook. \r", sFilePath	return -1Endstatic Function		XMLParse( how, xmlf, xslf, sKey, bDebugPrint )// read the XML file as a notebook// return: number of items read	variable	how			// switch determining how to store data, 0: keyword=value list (default option)	string  	xmlf			// root:xmlf is package data folder (location to store keyword=value strings) . MUST EXIST or routine ABORTS!	string  	xslf			// XSL data folder (location of style sheet parameters) .  MUST EXIST or routine ABORTS!	string  	sKey	variable	bDebugPrint 	// 0 or 1 : quite mode  or  print the data read (slow)	string  	sTxt	= ""	SVAR currXSLData = root:Packages:XML2IgorPro:currXSLData	SVAR currXMLData = root:Packages:XML2IgorPro:currXMLData		string where = ReplaceString( " ", xslf, "" )		xslf = "root:Packages:XML2IgorPro:" + where + "XSL"			if ( ! DataFolderExists( xmlf ) )		DoAlert 0, "No XML data folder"		return 0	endif	if ( ! DataFolderExists( xslf ) )		DoAlert 0, "No XSL data folder"		return 0	endif	currXSLData = xslf	currXMLData = xmlf		string cdf = GetDataFolder(1)		SetDataFolder $currXSLData			wave  /T	ename = ename	wave  /T	sname = sname	wave	xunits   = xunits		svar		eKey	   = eKey		SetDataFolder $currXMLData	KillStrings /A /Z		string nb = ksXML_NB_NM		string eKstr, eKstrf, fstr, estr		variable spo, spf, spo1	variable/D dv		variable jc, ic, dicmax, jmax, iemax		jmax = numpnts(ename)		// search starting lines for eKey code	eKstr = "<" + eKey	// print eKstr	Notebook $nb selection={startOfFile, startofFile}, findText={eKstr,0}	if ( ! V_flag )		sprintf sTxt, "No KEY string '%s'  in XML file. Aborting...\r",  eKstr		printf "Error: %s \r", sTxt		DoAlert 0, sTxt		return 0	endif	GetSelection notebook, $nb, 1	spo = V_startParagraph		// search to find ending eKey code	eKstrf = "</" + eKey + ">"		Notebook $nb selection={startofFile, startofNextParagraph}, findText={eKstrf,0}	GetSelection notebook, $nb, 1	// approximate maximum increment (paragraphs) for each element (item)	dicmax = V_startParagraph - spo					// unused		// count number of items	Notebook $nb selection={startOfFile, endOfFile}	GetSelection notebook, $nb, 1	spf = V_endParagraph		ic = 0	jc = 0	Notebook $nb selection={startOfFile, startofFile}	eKstr = "<" + eKey	do		Notebook $nb selection={startOfNextParagraph, startofNextParagraph}, findText={eKstr,0}		if (V_flag)			Notebook $nb selection={startofParagraph,endofChars}			GetSelection notebook, $nb, 3			iemax  = strsearch(S_selection,eKstr,0,2)+strlen(eKstr)			fstr	  = S_selection[iemax]			if ( ( cmpstr( fstr, ">" ) == 0 )  ||  ( cmpstr( fstr," " ) == 0 ) )				// printf "\t\tXMLParse(a)\t%s\tic:%5d\t\teKstr:'%s',    S_selection:'%s',    fstr:'%s',    V_startParagraph:%d \r", xmlf, ic, eKstr, S_selection, fstr, V_startParagraph				ic += 1			else				Notebook $nb selection={startofNextParagraph,startofNextParagraph}			endif		endif		jc +=1	while( jc < spf )		// maximum number of items	iemax = ic	// printf "\t\tXMLParse(b)\t%s\tic:%5d /%5d\tV_startPar:%2d\t \r", xmlf, ic, iemax, spf		// loop over items	ic = 0	Notebook $nb selection={startOfFile, startofFile}		// loop over all elements (items)		do		// search for eKey code for item ic		eKstr = "<" + eKey		Notebook $nb selection={startOfNextParagraph, startOfNextParagraph}, findText={eKstr,0}		if ( ! V_flag )			sprintf sTxt, "No KEY string '%s'  in XML file. Aborting...\r",  eKstr			printf "Error: %s \r", sTxt			DoAlert 0, sTxt			return 0		else			Notebook $nb selection={startofParagraph,endofChars}			GetSelection notebook, $nb, 3			spo = strsearch(S_selection,eKstr,0,2)+strlen(eKstr)			fstr = S_selection[spo]			if ( ( cmpstr( fstr,">" ) == 0 )  || ( cmpstr( fstr," " ) == 0 ) )						// retrieve NAME of item				Notebook $nb selection={startOfParagraph, startOfParagraph}, findText={"<" + sKEY,0}					Notebook $nb selection={startOfParagraph, endOfChars}				GetSelection notebook, $nb, 3				spo1 = V_startParagraph								// printf "\t\tXMLParse(c)\t%s\tic:%5d /%5d\tV_startPar:%2d\tS_Sel: '%s' \r", xmlf, ic, iemax, V_startParagraph, S_selection				//return 0								spf	= strsearch( S_selection, "</" + sKEY + ">", 0, 2 ) - 1				spo	= strsearch( S_selection, ">", spf, 3 )							estr 	= LowerStr( S_selection[ spo+1,spf ] ) 				 // printf "\t\tXMLParse(d)\t%s\tic:%5d /%5d\tspo:\t%3d\tspf:\t%3d\t'%s'\t \r", xmlf, ic, iemax, spo, spf, estr				 								string	  	element	= ""							// loop over VALUES for item (can be found in ANY order!)				jc = 0 				do										// find the jc'th VALUE start code					eKstr = "<" + ename[jc]					eKstrf = "</" + ename[jc] +">"								Notebook $nb selection={(spo1,0),(spo1,0)}, findText={eKstr,0}// 070210 ??? logical error ??? not investigated. The last XML entry seems to require ALL subentries . There was an error as <Video> was missing in last entry <lfdnr>13132  in Recipe.xml 					if (!V_flag)						sTxt = "Start value not found for : '" + eKstr + "' .  [element: '"   + element + "' ] . "						printf "Error: %s \r", sTxt						DoAlert 0, sTxt						return 0					endif					Notebook $nb selection={startofParagraph,endofChars}					GetSelection notebook, $nb, 3					spo = V_startParagraph										// find the jc'th VALUE end code					Notebook $nb selection={startOfParagraph,startOfParagraph}, findText={eKstrf,0}					if (!V_flag)						sTxt = "End value not found : '" + eKstrf + "' ." 						printf "Error: %s \r", sTxt						DoAlert 0, sTxt						return 0					endif					Notebook $nb selection={StartofParagraph,endofChars}					GetSelection notebook, $nb, 3					spf = V_startParagraph + 1										Notebook $nb selection={(spo,0),(spf,0)}					GetSelection notebook, $nb, 2										fstr = XMLParseValue(S_selection)					if ( numtype( xunits[jc] ) != 2 )						sscanf fstr,"%g", dv						dv *= xunits[jc]						sprintf fstr,"%g",dv					endif					fstr = sname[jc] +"=" + fstr +";"								element	+= fstr					// print "\tg", spo, spf, ename[jc], fstr//, S_selection							// printf "\t\tXMLParse( g )\t%s\tic:%5d /%5d\tjc:%2d\t/ %2d\t'%s' \r", xmlf, ic, iemax, jc, jmax, element					jc += 1									while( jc < jmax )					// Combine multiple elements belonging to 1 main key into a string list (e.g.  1 recipe has multiple recipe steps and  multiple ingredients )  				// Set the item value in the folder				string lstNm	= XMLElementNm( estr ) 				svar /Z  lstElem	= $lstNm				if ( ! svar_exists( lstElem ) )					string /G	$lstNm	=   XMLElementNm( estr ) 	// Prepend a letter to element wave name e.g. '123' -> 'L123'					svar 	   lstElem	= $lstNm					lstElem	= ""				endif				lstElem += element + "~"if ( bDebugPrint )				if ( mod( ic, kREDUCE_PRINT ) == 0 )					// print only 1 line for every 40					 // printf "\t\tXMLParse( h )\t%s\tic:%5d /%5d\tjc:%2d\t/ %2d\t'%s'\t'%s.....' \r", xmlf, ic, iemax, jc, jmax, estr, ConvertUTF8( element[ 0, 200] )					 printf "\t\tXMLParse( l )\t%s\tic:%5d /%5d\tjc:%2d\t/ %2d\testr:'%s'\tn:%2d\t'%s...' \r", xmlf, ic, iemax, jc, jmax, estr, ItemsInList( lstElem, "~"), lstElem[ 0, 250 ]				endifendif								ic += 1				Notebook $nb selection={(spo1,0),(spo1,0)}			else				Notebook $nb selection={StartofNextParagraph,StartofNextParagraph}			endif		endif			while( ic < iemax )		SetDataFolder $cdf		KillWindow $nb		return	iemaxEnd//================================================================================// Access functions for the data strings and lists once they are in the folders.// These functions are only required if the main key is a number. // In this case a maker starting with letter is prepended to make it a valid Igor name.// todo : Check if the main key is a number and only then prepend a UNIQUE string which is unlikely to appear in the data....// 	...as when retrieving the numerical main key this UNIQUE string must be removed again.// toThink: is not really a common function  as the marker  'ksUNIQUE_MARKER'  contains 'JL'  ...............static strconstant	ksUNIQUE_MARKER	= "JL_UF_"Function	/S	XMLElementNm( sLfdNr )	string  	sLfdNr	return	ksUNIQUE_MARKER + sLfdNr 					// prepend a letter marker because Igor names must not start with a digitEndFunction	/S	XMLNr2EleNm( lfdnr )	variable	lfdnr	return	ksUNIQUE_MARKER + num2str( lfdnr )			// prepend a letter marker because Igor names must not start with a digitEndFunction		XMLEleNm2Nr( sEleNm )	string  	sEleNm	return	str2num( sEleNm[ strlen( ksUNIQUE_MARKER ), inf ] )	// strip the leading marker prepended  because Igor names must not start with a digitEndFunction	/S	XMLElementsInDF( sDF )// Returns list of strings contained in the data folder 'sDF' . Returns empty list if there are no strings or if the data folder does not exist. 	string  	sDF	string  	sCDF	= GetDataFolder(1)	if ( ! DataFolderExists( sDF ) )		return ""	endif	SetDataFolder	$ sDF	string  	sObjName	string  	lstNames	= ""	variable	index		= 0	do		sObjName = GetIndexedObjName( ":", 3, index )	// 3 means search strings		if ( strlen( sObjName ) == 0 )			break		endif		index += 1		lstNames	+= sObjName + ";"	while( 1 )	SetDataFolder	$sCDF	return	ReplaceString( ksUNIQUE_MARKER, lstNames, "" )Endstatic Function	/S 	XMLParseValue( lstr )	string  	lstr			// line containing value to parse,  assumed to be in possible format 						// ...<name bla bla bla><!--possible comments>value</name>   including \r values ...	string  	rstr	variable	so, sf		lstr = ReplaceString( "\r", lstr, "" )		sf	= strsearch( lstr, "</", 0 )	so	= strsearch( lstr, ">", sf, 3 )	rstr	= lstr[ so+1, sf-1 ]	// rstr = ReplaceString(" ",rstr,"")	//???	return rstrEndFunction	/S	ConvertUTF8( sText )//	string  	sText	sText	= ReplaceString( "Ã„",  sText, "Ä" )	sText	= ReplaceString( "Ã–",  sText, "Ö" )	sText	= ReplaceString( "àœ",   sText, "Ü" )	sText	= ReplaceString( "Ã¤",  sText, "ä" )	sText	= ReplaceString( "Ã¶",  sText, "ö" )	sText	= ReplaceString( "Ã¼", sText, "ü" )	sText	= ReplaceString( "ÃŸ",  sText, "ß" )	sText	= ReplaceString( "Â°",  sText, "°" )	sText	= ReplaceString( "Ã",   sText, "à" )	sText	= ReplaceString( "Ã¨",   sText, "è" )	// ??	sText	= ReplaceString( "à¨",   sText, "è" )	// ??	sText	= ReplaceString( "Ã©", sText, "é" )	sText	= ReplaceString( "à©", sText, "é" )	// Topfensoufflé	sText	= ReplaceString( "àª",   sText, "ê" )	sText	= ReplaceString( "à®", sText, "î" )	// ??	sText	= ReplaceString( "Ã®", sText, "î" )	// ??	return	sTextEnd